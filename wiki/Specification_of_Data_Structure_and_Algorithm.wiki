#summary Specification for the technical specification.

=Data Structure and Algorithm=
The target audience for the proposed digital logic simulator is computer science students in their first year. The first year of a computer science syllabus typically contains a course in ”Digital Logic” that treats the subject on a functional or gate level and is certainly not too concerned about physical details of logic circuits (like wire delays, voltage drops due to wire resistance, etc.). Thus, it has been decided to keep the simulation as close as possible to the functional level, where gates represent boolean functions from input signals (or wire in this model carry boolean values) to output signals. However, it has also been decided that the simulator should be capable of simulating any valid digital circuit.

To achieve a good compromise between both goals, the simulator will impose certain restrictions on circuits and the simulation will also model some digital circuit characteristics that go beyond pure functional simulation.

Restrictions on the data structures:
 * If the user is allowed to create wires which connect two wires, it is possible to create circuits which (if at all) only a simulator that models the physical properties of a circuit very accurately can simulate. The simplest example is a circuit where two wire carrying different logic signals are joined ([http://delta09.googlecode.com/svn/trunk/documents/01.pdf Indeterminable Output]).
 To avoid such situations in the chosen model, wires are only allowed between an input of a logic component and an output of a logic component (not necessarily different components). Furthermore, inputs to logic components are only allowed to be connected to one wire.
 This restriction does not in any way limit the number of different circuit the user can build but it does prevent the user from building circuit that cannot be simulated on a gate or functional level.
 * Only one global clock is allowed which should be appropriate as only few circuits need more than one clock and even complex circuits (say a microprocessor) can be implemented with only one clock.

Extensions to the functional simulation:
 * A purely functional functional simulation would not emulate gate delays. The proposed simulator does not, however, disallow cycles in the circuit. Since cycles are allowed, circuits which are not stable, i.e. oscillate, can be constructed. The classic example is a ring of three inverters ([http://delta09.googlecode.com/svn/trunk/documents/inverter_ring2.pdf Inverter Ring], the depicted example uses a NAND gate instead of an inverter so that the initial configuration produces deterministic results). Without gate delays this circuit cannot be simulated, at all, and therefore the simulation model needs gate delays. To stay close to a functional simulation the algorithm will use unit gate delays for all gates.
 * There are certain circuits that exhibit a behaviour that cannot be described in terms on combinatorial logic, that is they produce metastable outputs. Since it is algorithmically hard to detect whether a circuit belongs to this class of circuits and since this class includes components which are essential for sequential logic like RS latches ([http://delta09.googlecode.com/svn/trunk/documents/latch.pdf RS-Latch]), this class of circuits must not be rejected by the simulator. To simulate such circuits deterministically, a third logic state X (apart from 0 and 1) is introduced, representing logic states which are unknown or cannot be inferred by boolean logic.

==Data Structure==
The natural choice for a circuit representation is a graph-like data structure where vertices represent logic components and edges represent wires between component inputs and component outputs. Components are sub-circuits consisting of gates connected by wires (again, a graph-like data structure). Allowing circular circuits and including of gate delays make it, however, impossible to simulate a circuit component-wise. Thus, to allow editing the circuit in the GUI on a component level on the one hand and simulating the circuit on a gate level on the other hand, a data structure which can represent both has been designed: The data structure maintaining the circuit will hold two graphs simultaneously: One graph, in which vertices represent logic components, and one graph, in which vertices represent gates. When the user adds a logic component to the circuit, the component is first added to the former graph, the internal representation of the component consisting of gates and wires is then read and added to the latter graph (for more detail, see the UML diagrams [\ref{???}]).

==Algorithm==
For performance reasons, the simulation algorithm will be event-driven, i.e. the actual simulation algorithm is only run when an input signal changes (inputs are buttons and switches on the board `[`these have to be checked regularly`]`, constant input 0 and 1, and the clock provided by the simulator):

When an input signal changes, the algorithm sets the value, that each of the wires that is connected to the input carries, to the new logic value and saves the list of gates (or rather inputs to gates) that are connected (by one of those wires) to this input. And after a fixed time (a specified unit-time gate delay), the algorithm re-evaluates the output of each of the gates in the list and propagates all output values, that have changed, in a similar fashion. To schedule such input signal changes and re-evaluations of gate outputs, the algorithm keeps a priority queue.